package main.methods;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import main.Main;

public class ProcessInput {

	private ProcessInput(){};
	
	/*
	 * Build words from options
	 * NOTE:
	 * Total number of generated words is: X * Y
	 * Where X is number of words generated by combinations2D and Y same but from heapPermutation
	 * Example: Input is {{"sad","SAD"},{"najebo","NAJEBO"},{"sam","SAM"},{"test","TEST", "Test", "ayy"}}
	 * X would then be 2*2*2*4 = 32 
	 * Y would be 4! (1*2*3*4) because we have 4 blocks (4 words that make a sentence)
	 * Total = 768
	 */	
		
	//int Y = inputWords.size(); daje nullPointer exception ako je input prazan		
	public static List<List<String>> buildWords( ArrayList<String> inputWords , char combiningSeparator, char optionSeparator){
		int i;
		int X;
		int Y = inputWords.size();
		List<List<String>> tempOutput = new ArrayList<List<String>>();
		
		//Add Y words and start adding words and their options
		for( i=0; i<Y; i++){
			tempOutput.add(new ArrayList<String>());
			extractWords( tempOutput, i, inputWords.get(i).toString(), combiningSeparator, optionSeparator );
		}
		
		Main.txtrLog.appendDebug( "Base words that were extracted from input(without their options):" );
		for( i=0; i<Y; i++){
			for (String value : tempOutput.get(i)) {
				Main.txtrLog.appendDebug( (i+1) + ":" + value );
			}
		}
		
		return tempOutput;
	}
	
	
	
	
	/*
	 * Extract words from string
	 */
	
	public static void extractWords( List<List<String>> inputList , int index , String extractString , char combiningSeparator, char optionSeparator ){
		String baseString;
		String optionString;
		int indexCombining = extractString.indexOf(combiningSeparator);

		if( indexCombining!=-1 ){
			/*
			 * There is combining separator in string so we will break the word
			 * in 2 parts and call this function again with each part
			 */
			Main.txtrLog.appendDebug("Found combining separator in string: " + extractString );
		   String tempInput = extractString ;
		   StringBuilder temp = new StringBuilder();
		   for( int i=0; i<tempInput.length(); i++ ){
			   if( tempInput.charAt(i)==combiningSeparator ){
				   extractWords( inputList, index, temp.toString() , combiningSeparator, optionSeparator );
				   temp = new StringBuilder();

			   }else if( i==tempInput.length()-1 ){
				   temp.append( tempInput.charAt(i) );
				   extractWords( inputList, index, temp.toString() , combiningSeparator, optionSeparator );
				   //temp = new StringBuilder();
			   }else{
				   temp.append( tempInput.charAt(i) );
			   }
		   }
		   return;
		}else{
			/*
			 * There is NO combining separator in word meaning word is single
			 * Now we look if word has additional options or not
			 */
			int indexOption = extractString.indexOf(optionSeparator);
			if( indexOption!=-1 ){
				/*
				 * There are options in the word so we will have to generate new words
				 * based on those options and base string (which is an original word)
				 */
				baseString = extractString.substring(0, indexOption);
				optionString = extractString.substring(indexOption);

				/*
				 * Split option string to multiple parts then call function for every option part
				 * We used optionSeparatorDouble because option separator is a double char in the program
				 */
				String optionSeparatorDouble = optionSeparator+""+optionSeparator;
				String[] word = optionString.split(optionSeparatorDouble);
				word = removeEmpty(word);
				
				Main.txtrLog.appendDebug("Printing option array for word: '" + extractString + "' in format (ID:option) :" );
				for(int k =0; k<word.length;k++)
					Main.txtrLog.appendDebug( k + ": " + word[k] );
				
					for(String optionPart: word){
						/*
						 * Eliminate empty words produced by optionString.split
						 */
						//log.append("Test:"+optionPart+"\n");
						//if(!optionPart.isEmpty()){
							/*
							 * Before calling the option method first extract sub-options
							 */
						Main.txtrLog.appendDebug("Spliting:'"+optionPart+"' to suboptions!" );
							String[] subOptions = optionPart.split( ""+optionSeparator );
							/*
							 * Now remove empty words from sub-options produced by optionString.split
							 */
							subOptions = removeEmpty(subOptions);
							Main.txtrLog.appendDebug("Printing suboptions (ID:suboption) where ID=0 means base option:" );
							for(int k =0; k<subOptions.length;k++)
								Main.txtrLog.appendDebug(k+":"+subOptions[k] );
							/*
							 * String in first index of finalSubOptions is the option while rest are subOptions
							 */
							//Log.writeDebug("baseString: "+baseString+"  ,optionPart:"+optionPart+"  ,subOptions: (printed above)");
							WordOptions.extractOptions( inputList, index, baseString, subOptions );
						//}
					}
				return;
			}else{
				/*
				 * There are no options in word so we just add it to the list
				 */
				Main.txtrLog.appendDebug("No options in word:"+extractString );
				inputList.get(index).add(extractString);
				return;
			}
		}
		
	}




	/*
	 * Eliminate empty words in string array
	 * Words are considered empty if they are null or have 0 characters
	 */
	
	public static String[] removeEmpty(String[] input){
		List<String> list = new ArrayList<String>(Arrays.asList(input));
		list.removeAll(Arrays.asList("", null));
		return list.toArray(new String[0]);
	}
	

}
